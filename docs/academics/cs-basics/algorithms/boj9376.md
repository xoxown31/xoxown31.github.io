---
layout: default
title: BOJ 9376 - 탈옥
parent: Algorithms
grand_parent: Computer Science Basics
nav_order: 3
---

# 🐦 BOJ 9376 - 탈옥

> **문제 링크:** [BOJ 9376 - 탈옥](https://www.acmicpc.net/problem/9376)

---

## 1. 문제 설명

| 난이도 | 키워드         |
|:------:|:--------------|
| Platinum 4 | 0-1 BFS, Dijkstra |

- **문제 요약**: 
  - 두 명의 죄수가 감옥에서 탈출하는 최소 비용을 구하는 문제
  - 간선 가중치가 0 또는 1인 격자 그래프

---

## 2. 문제 풀이

이 문제는 **0-1 BFS** 또는 **Dijkstra** 알고리즘을 사용하여 해결할 수 있습니다. 감옥의 벽을 부수는 비용이 1이고, 빈 공간을 이동하는 비용이 0이므로, 가중치가 0과 1인 그래프에서 최단 경로를 찾는 문제로 변환할 수 있습니다.


### ⚠️ Dijkstra

- 간선 가중치가 0 또는 1인 경우에도 우선순위 큐를 사용하여 최단 경로를 찾을 수 있음
- 시간복잡도: $$ O((V + E) \log V) $$
- **비효율적**이므로 적합하지 않음

### ✅ 0-1 BFS

- 덱(deque)을 사용하여 가중치가 0인 간선은 앞에, 가중치가 1인 간선은 뒤에 추가
- 시간복잡도: $$ O(V + E) $$
- 세 번의 0-1 BFS를 수행하여 세 위치(죄수 두 명과 감옥 밖)에서 각 칸까지의 최소 비용을 계산

> **Tip:**
> - 탈출 했는지 여부는 격자를 넓혀 감옥 밖을 포함시키는 방식으로 처리
> - 벽을 부수는 비용이 1이므로, 세 위치에서의 비용 합산 후 2를 빼줌
> - 탐색 문제에서 심화 문제로 넘어가는 좋은 예시

---

## 3. 코드

```python
from collections import deque
import sys

input = sys.stdin.readline

dij = [(0,1),(1,0),(0,-1),(-1,0)]
isin = lambda i,j : 0 <= i < h+2 and 0 <= j < w+2

def bfs(i,j):
    dq = deque([(i,j)])
    visited = [[-1] * (w+2) for _ in range(h+2)]
    visited[i][j] = 0
    while dq:
        ui, uj = dq.popleft()

        for di, dj in dij:
            vi, vj = ui+di, uj+dj

            if isin(vi,vj) and visited[vi][vj] == -1:
                if board[vi][vj] in '.$':
                    visited[vi][vj] = visited[ui][uj]
                    dq.appendleft((vi,vj))
                elif board[vi][vj] == '#':
                    visited[vi][vj] = visited[ui][uj] + 1
                    dq.append((vi,vj))
    return visited


T = int(input())

for _ in range(T):
    
    h, w = map(int, input().split())

    board = ['.'*(w+2)]+['.'+input().strip()+'.' for _ in range(h)]+['.'*(w+2)]

    l = []

    for i in range(1, h+1):
        for j in range(1, w+1):
            if board[i][j] == '$':
                l.append((i,j))
    
    a = bfs(l[0][0], l[0][1])
    b = bfs(l[1][0], l[1][1])
    c = bfs(0, 0)

    ans = sys.maxsize

    for i in range(h+2):
        for j in range(w+2):
            if a[i][j] != -1 and b[i][j] != -1 and c[i][j] != -1:
                t = a[i][j] + b[i][j] + c[i][j]
                if board[i][j] == '*': continue
                if board[i][j] == '#': t -= 2
                ans = min(ans, t)
    
    print(ans)
```

---

### 💡 풀이 요약

- 0-1 BFS를 사용하여 가중치가 0과 1인 그래프에서 최단 경로를 효율적으로 탐색
- 탐색을 세 번 수행하여 각 위치에서의 최소 비용을 계산하고 합산
- 벽을 부수는 비용을 고려하여 최종 비용 계산

---