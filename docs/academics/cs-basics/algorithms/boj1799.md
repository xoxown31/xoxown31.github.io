---
layout: default
title: BOJ 1799 - 비숍
parent: Algorithms
grand_parent: Computer Science Basics
nav_order: 2
---

# 🐦 BOJ 1799 - 비숍

## 1. 문제 설명

- **난이도**: Gold 4
- **키워드**: 백트래킹, 비트마스킹
- **링크**: [BOJ 1799 - 비숍](https://www.acmicpc.net/problem/1799)
- **문제 요약**: N x N 체스판에 비숍을 놓아 최대한 많은 비숍을 놓는 문제. 비숍은 대각선으로만 이동할 수 있으며, 서로 공격할 수 없어야 함.

## 2. 문제 풀이

이 문제는 백트래킹을 사용하여 비숍을 놓는 최적의 방법을 찾는 문제입니다. 비숍은 대각선으로만 이동할 수 있기 때문에, 대각선에 비숍이 놓이지 않도록 주의해야 한다. 체스판의 크기가 N x N (1 ≤ N ≤ 10) 이므로, 어떤 알고리즘이 적합할지 고민해보자.

### 브루트포스

브루트포스로 모든 경우의 수를 탐색할 경우 시간복잡도를 계산해보면, N이 최대인 10일 때, 10 x 10 체스판에서 비숍을 놓는 경우의 수는 각각의 칸에 비숍을 놓거나 놓지 않는 경우가 있으므로, 2^(N^2) = 2^100이 된다. 또한 경우의 수에 대해서 조건을 만족하는지 확인해야 하므로, 이 때의 시간복잡도를 고려해야 한다. 이때 시간복잡도는 O(2^(N^2) * N^2)이 된다. 이는 매우 비효율적이므로, 브루트포스는 적합하지 않다.

### 백트래킹

백트래킹을 사용하여 비숍을 놓는 최적의 방법을 찾는다. 대각선에 비숍이 놓이지 않도록 하기 위해, 각 대각선에 비숍이 놓였는지 여부를 기록하는 배열을 사용한다. 백트래킹에서 가장 중요한 것은 가지치기이다. 가지치기를 하는 방법을 잘 정의내리는 것이 이 문제의 핵심이다. 이를 쉽게 이해하기 위하여 룩을 놓는 문제로 생각해보자. 룩은 가로와 세로로 이동할 수 있으므로, 각 행과 열에 하나씩만 놓을 수 있다. 예를 들어 row와 column 배열을 사용하여 각 행과 열에 룩이 놓였는지 여부를 기록하고, 이를 통해 가지치기를 하여 유망한 경우만 탐색하도록 한다.
비숍의 경우에도 비슷하게 대각선에 비숍이 놓였는지 여부를 기록하는 배열을 사용하여 가지치기를 한다. 각각의 두 대각선을 확인하는 배열을 통해 구현하는 것도 가능하지만, 대각선의 인덱스를 계산하여 하나의 배열로 관리하는 것이 더 효율적이다. 왜냐하면, i 자체를 한 대각선에 대해 서로 독립적인 값으로 사용하고, j를 나머지 대각선에 대한 인덱스로서 사용하여 j에 대한 대각선만 조건으로 처리하면 되기 때문이다.
쉽게 말해, i는 현재 대각선의 인덱스이고, j는 i에 해당하는 대각선에서 하나씩 비숍을 놓는는다고 생각하면 된다. 이때, 나머지 대각선에 대해서 조건을 통해 가지치기로 효율적인 백트래킹을 구현할 수 있다.

## 3. 코드

```python
N = int(input())

board = [[int(x) for x in input().split()] for _ in range(N)]
isin = lambda i,j : 0 <= i < N and 0 <= j < N

dec = [False] * (2*N-1)
res = 0

def dfs(i, count):
    global res
    res = max(count, res)
    if i == 2*N-1:
        return
    b = 0
    for j in range(N):
        if not isin(j, i-j) or dec[i-2*j+N-1]: 
            continue

        if board[j][i-j]:
            dec[i-2*j+N-1] = True
            dfs(i+1, count+1)
            dec[i-2*j+N-1] = False
        elif b == 0:
            dfs(i+1, count)
            b += 1

dfs(0,0)
print(res)
```