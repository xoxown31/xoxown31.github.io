---
layout: default
title: Singleton Pattern
parent: Object-Oriented Programming
grand_parent: Computer Science Basics
---

# 🧱 Proxy Pattern

## 이론

프록시 패턴은 다른 객체에 대한 접근을 제어하기 위해 대리 객체를 사용하는 디자인 패턴입니다.
이 패턴은 실제 객체에 대한 접근을 제어하거나, 객체의 생성 비용을 줄이기 위해 사용됩니다.
프록시 패턴은 주로 다음과 같은 상황에서 사용됩니다.
- 객체의 생성 비용이 크거나, 객체가 무거운 리소스를 사용하는 경우
- 객체에 대한 접근을 제어하고 싶을 때
- 객체의 실제 구현을 숨기고, 인터페이스를 통해 접근하고 싶을 때

## 종류

프록시 패턴은 다음과 같은 종류가 있습니다:
- **가상 프록시(Virtual Proxy)**: 실제 객체의 생성 비용이 크거나, 객체가 무거운 리소스를 사용하는 경우에 사용됩니다. 가상 프록시는 실제 객체를 필요할 때까지 생성하지 않고, 클라이언트의 요청을 처리합니다.
- **원격 프록시(Remote Proxy)**: 실제 객체가 네트워크를 통해 접근되는 경우에 사용됩니다. 원격 프록시는 클라이언트와 실제 객체 간의 통신을 관리합니다.
- **보호 프록시(Protection Proxy)**: 실제 객체에 대한 접근을 제어하고, 보안을 강화하기 위해 사용됩니다. 보호 프록시는 클라이언트의 요청을 가로채고, 필요한 경우에만 실제 객체에 접근합니다.
- **캐시 프록시(Cache Proxy)**: 실제 객체의 결과를 캐싱하여, 성능을 향상시키기 위해 사용됩니다. 캐시 프록시는 클라이언트의 요청을 처리하고, 이전에 계산된 결과를 반환합니다.
- **스마트 프록시(Smart Proxy)**: 실제 객체에 대한 추가적인 기능을 제공하기 위해 사용됩니다. 스마트 프록시는 클라이언트의 요청을 처리하고, 필요한 경우에만 실제 객체에 접근합니다.

프록시 패턴은 종류가 다양하며, 각 종류는 특정 상황에서 유용하게 사용될 수 있습니다.

## 구조

프록시 패턴은 다음과 같은 구조를 가집니다:

- **주제(Subject) 인터페이스**: 실제 객체와 프록시 객체가 구현해야 하는 인터페이스입니다.
- **실제 객체(Real Subject) 클래스**: 주제 인터페이스를 구현하는 클래스입니다. 실제 작업을 수행합니다.
- **프록시(Proxy) 클래스**: 주제 인터페이스를 구현하며, 실제 객체에 대한 접근을 제어하는 클래스입니다. 실제 객체를 포함하고, 클라이언트의 요청을 처리합니다.

프록시 패턴은 다음과 같은 속성과 메서드를 포함합니다:

- **실제 객체 참조**: 프록시 객체가 실제 객체를 참조하는 변수입니다. 이 변수는 실제 객체의 인스턴스를 저장합니다.
- **요청 처리 메서드**: 클라이언트의 요청을 처리하는 메서드입니다. 이 메서드는 실제 객체의 메서드를 호출하거나, 추가적인 작업을 수행합니다.
- **프록시 생성 메서드**: 실제 객체를 생성하는 메서드입니다. 이 메서드는 실제 객체를 생성하고, 프록시 객체에 할당합니다.

## 특징
- **접근 제어**: 실제 객체에 대한 접근을 제어할 수 있습니다.
- **지연 초기화**: 실제 객체를 필요할 때까지 생성하지 않을 수 있습니다.
- **인터페이스 사용**: 실제 객체와 프록시 객체가 동일한 인터페이스를 구현하여, 클라이언트 코드가 두 객체를 동일하게 사용할 수 있습니다.
- **책임 분리**: 실제 객체의 책임을 프록시 객체에 분리하여, 클라이언트 코드의 책임을 줄입니다.
- **보안**: 실제 객체에 대한 접근을 제한하여, 보안을 강화할 수 있습니다.

## 예제 코드

프록시 패턴을 사용하여 이미지 로딩을 최적화하는 예제를 살펴보겠습니다.

```java
// 주제 인터페이스
public interface Image {
    void display();
}

// 실제 객체 클래스
public class RealImage implements Image {
    private String filename;

    public RealImage(String filename) {
        this.filename = filename;
        loadImageFromDisk();
    }

    private void loadImageFromDisk() {
        System.out.println("Loading " + filename);
    }

    @Override
    public void display() {
        System.out.println("Displaying " + filename);
    }
}

// 프록시 클래스
public class ProxyImage implements Image {
    private RealImage realImage;
    private String filename;

    public ProxyImage(String filename) {
        this.filename = filename;
    }

    @Override
    public void display() {
        if (realImage == null) {
            realImage = new RealImage(filename);
        }
        realImage.display();
    }
}

// 클라이언트 코드
public class Client {
    public static void main(String[] args) {
        Image image1 = new ProxyImage("image1.jpg"); // 이미지가 실제로 로드되지 않음
        Image image2 = new ProxyImage("image2.jpg"); // 이미지가 실제로 로드되지 않음

        image1.display(); // 실제로 로드됨
        image2.display(); // 실제로 로드됨
    }
}
```

이 예제에서 `ProxyImage` 클래스는 `RealImage` 클래스에 대한 프록시 역할을 합니다.
`ProxyImage`는 실제 이미지가 필요할 때만 `RealImage`를 생성하고, 이미지를 표시하는 메서드를 호출합니다. 이를 통해 이미지 로딩을 최적화하고, 불필요한 리소스 사용을 줄일 수 있습니다.

"어차피 나중에 똑같은 리소스를 사용하는데 의미 없는 것 아닌가?"라고 생각할 수도 있지만,
서버와 클라이언트 간의 통신에서 프록시 패턴을 사용하면, 이야기가 달라집니다.
프록시 패턴을 사용하면 클라이언트는 실제 객체에 직접 접근하지 않고, 프록시 객체를 통해 간접적으로 접근하게 됩니다.
이 과정에서 프록시 객체는 클라이언트의 요청을 가로채고, 필요한 경우에만 실제 객체를 생성하거나, 요청을 전달합니다.
이러한 방식은 네트워크 대역폭을 절약하고, 서버의 부하를 줄이는 데 도움이 됩니다.


## 결론

프록시 패턴은 객체에 대한 접근을 제어하고, 리소스 사용을 최적화하는 데 유용한 디자인 패턴입니다.
이 패턴은 실제 객체에 대한 접근을 프록시 객체를 통해 간접적으로 수행함으로써,
클라이언트 코드와 실제 객체 간의 결합도를 낮추고, 객체의 생성 비용을 줄일 수 있습니다.

보통 프록시 패턴은 서버-클라이언트 구조, 원격 프로시저 호출(RPC), 가상 프록시 등 다양한 상황에서 사용됩니다.
프록시 패턴을 사용하면 객체의 생성 비용을 줄이고, 객체에 대한 접근을 제어할 수 있어,
애플리케이션의 성능과 보안을 향상시킬 수 있습니다.