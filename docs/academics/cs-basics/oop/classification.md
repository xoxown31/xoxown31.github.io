---
layout: default
title: Classification of Patterns
parent: Object-Oriented Programming
grand_parent: Computer Science Basics
---

# 🧱 Classification of Patterns

## 디자인 패턴 분류

객체지향 프로그래밍에서 디자인 패턴은 소프트웨어 설계에서 자주 발생하는 문제를 해결하기 위한 일반적인 솔루션입니다.
디자인 패턴은 코드의 재사용성을 높이고, 유지보수를 용이하게 하며, 코드의 가독성을 향상시키는 데 도움을 줍니다.
디자인 패턴은 다양한 유형으로 분류될 수 있으며, 각 유형은 특정 문제를 해결하기 위한 접근 방식을 제공합니다.

GoF에서는 총 23개의 디자인 패턴을 정의하였으며, 이들은 크게 세 가지 범주로 나눌 수 있습니다: 생성 패턴(Creational Patterns), 구조 패턴(Structural Patterns), 행동 패턴(Behavioral Patterns).
바로 이 세 가지 범주들에 대해 자세히 알아보겠습니다.

## 생성 패턴

생성 패턴은 객체 생성과 관련된 문제를 해결하기 위한 패턴입니다.
이 패턴은 객체의 생성 과정을 추상화하여, 객체 생성의 복잡성을 줄이고, 객체의 생성 방식을 유연하게 변경할 수 있도록 합니다.
생성 패턴의 주요 특징은 객체 생성의 책임을 분리하여, 객체 생성 로직을 캡슐화하는 것입니다.

GoF에서 정의한 생성 패턴은 총 5가지입니다:
- **싱글턴 패턴 (Singleton Pattern)**: 클래스의 인스턴스가 오직 하나만 존재하도록 보장하는 패턴입니다.
- **팩토리 메서드 패턴 (Factory Method Pattern)**: 객체 생성의 인터페이스를 정의하고, 서브클래스에서 객체를 생성하는 방법을 결정하는 패턴입니다.
- **추상 팩토리 패턴 (Abstract Factory Pattern)**: 관련된 객체들의 집합을 생성하는 인터페이스를 제공하는 패턴입니다.
- **빌더 패턴 (Builder Pattern)**: 복잡한 객체의 생성 과정을 단계별로 분리하여, 객체를 구성하는 방법을 유연하게 변경할 수 있도록 하는 패턴입니다.
- **프로토타입 패턴 (Prototype Pattern)**: 객체의 복제를 통해 새로운 객체를 생성하는 패턴입니다. 기존 객체를 복제하여 새로운 객체를 생성함으로써, 객체 생성 비용을 줄일 수 있습니다.

## 구조 패턴

구조 패턴은 객체와 클래스의 조합을 통해 더 큰 구조를 형성하는 데 도움을 주는 패턴입니다.
구조 패턴은 객체 간의 관계를 정의하고, 객체의 구조를 변경하지 않고도 객체의 기능을 확장할 수 있도록 합니다.
구조 패턴의 주요 특징은 객체 간의 관계를 정의하고, 객체의 구조를 변경하지 않고도 객체의 기능을 확장할 수 있는 것입니다.

GoF에서 정의한 구조 패턴은 총 7가지입니다:
- **어댑터 패턴 (Adapter Pattern)**: 서로 다른 인터페이스를 가진 객체들을 연결하여, 호환되지 않는 인터페이스를 조정하는 패턴입니다.
- **브리지 패턴 (Bridge Pattern)**: 추상화와 구현을 분리하여, 두 개의 독립적인 계층을 생성하는 패턴입니다. 이 패턴은 구현의 변경 없이도 추상화를 확장할 수 있도록 합니다.
- **컴포지트 패턴 (Composite Pattern)**: 객체들을 트리 구조로 구성하여, 개별 객체와 복합 객체를 동일하게 다룰 수 있도록 하는 패턴입니다.
- **데코레이터 패턴 (Decorator Pattern)**: 객체에 추가적인 기능을 동적으로 추가할 수 있는 패턴입니다. 이 패턴은 객체의 구조를 변경하지 않고, 기존 객체에 새로운 기능을 추가할 수 있도록 합니다.
- **퍼사드 패턴 (Facade Pattern)**: 복잡한 서브시스템에 대한 간단한 인터페이스를 제공하는 패턴입니다. 이 패턴은 서브시스템의 복잡성을 숨기고, 클라이언트가 서브시스템을 쉽게 사용할 수 있도록 합니다.
- **플라이웨이트 패턴 (Flyweight Pattern)**: 객체의 공유를 통해 메모리 사용을 최적화하는 패턴입니다. 이 패턴은 동일한 객체를 여러 번 생성하는 대신, 하나의 객체를 공유하여 메모리 사용을 줄입니다.
- **프록시 패턴 (Proxy Pattern)**: 다른 객체에 대한 접근을 제어하기 위해 대리 객체를 사용하는 패턴입니다. 이 패턴은 실제 객체에 대한 접근을 제어하거나, 객체의 생성 비용을 줄이기 위해 사용됩니다.

## 행동 패턴

행동 패턴은 객체 간의 상호작용과 책임 분배를 정의하는 패턴입니다.
행동 패턴은 객체 간의 협력을 정의하고, 객체의 행동을 캡슐화하여, 객체 간의 상호작용을 유연하게 변경할 수 있도록 합니다.

GoF에서 정의한 행동 패턴은 총 11가지입니다:
- **책임 연쇄 패턴 (Chain of Responsibility Pattern)**: 요청을 처리할 수 있는 객체의 체인을 구성하여, 요청을 처리할 객체를 동적으로 결정하는 패턴입니다.
- **커맨드 패턴 (Command Pattern)**: 요청을 객체로 캡슐화하여, 요청의 매개변수화, 큐잉, 로깅 등을 가능하게 하는 패턴입니다.
- **인터프리터 패턴 (Interpreter Pattern)**: 언어의 문법을 정의하고, 해당 문법을 해석하는 객체를 생성하는 패턴입니다. 이 패턴은 주로 언어 처리기나 컴파일러에서 사용됩니다.
- **이터레이터 패턴 (Iterator Pattern)**: 컬렉션 객체의 내부 구조를 노출하지 않고, 컬렉션의 요소에 순차적으로 접근할 수 있는 방법을 제공하는 패턴입니다.
- **중재자 패턴 (Mediator Pattern)**: 객체 간의 상호작용을 중재하는 객체를 정의하여, 객체 간의 의존성을 줄이는 패턴입니다. 이 패턴은 객체 간의 상호작용을 중앙 집중화하여, 객체 간의 결합도를 낮춥니다.
- **메멘토 패턴 (Memento Pattern)**: 객체의 상태를 저장하고, 나중에 해당 상태로 되돌릴 수 있는 패턴입니다. 이 패턴은 객체의 상태를 캡슐화하여, 객체의 내부 구조를 노출하지 않고도 상태를 저장할 수 있습니다.
- **옵저버 패턴 (Observer Pattern)**: 객체의 상태 변화에 따라 다른 객체에게 알림을 보내는 패턴입니다. 이 패턴은 객체 간의 일대다 관계를 정의하여, 객체의 상태 변화에 대한 반응을 구현할 수 있습니다.
- **상태 패턴 (State Pattern)**: 객체의 상태에 따라 객체의 행동을 변경하는 패턴입니다. 이 패턴은 객체의 상태를 캡슐화하여, 객체의 행동을 상태에 따라 동적으로 변경할 수 있도록 합니다.
- **전략 패턴 (Strategy Pattern)**: 알고리즘을 정의하고, 해당 알고리즘을 캡슐화하여, 클라이언트가 알고리즘을 동적으로 변경할 수 있도록 하는 패턴입니다. 이 패턴은 알고리즘의 변경을 클라이언트 코드에 영향을 주지 않고 수행할 수 있습니다.
- **템플릿 메서드 패턴 (Template Method Pattern)**: 알고리즘의 구조를 정의하고, 일부 단계를 서브클래스에서 구현하도록 하는 패턴입니다. 이 패턴은 알고리즘의 기본 구조를 정의하고, 세부 구현을 서브클래스에 위임합니다.
- **비지터 패턴 (Visitor Pattern)**: 객체 구조를 변경하지 않고, 객체에 새로운 기능을 추가할 수 있는 패턴입니다. 이 패턴은 객체 구조를 순회하면서, 각 객체에 대해 특정 작업을 수행할 수 있도록 합니다.

각 디자인 패턴들의 예시로 마무리하겠습니다.

| 분류 | 디자인 패턴 | 예시 |
| --- | --- | --- |
| 생성 패턴 | 싱글턴 패턴 | 피자 종업원 A씨가 유일하도록 보장 |
| 생성 패턴 | 팩토리 메서드 패턴 | 주문에 따라 다른 음식 생성 |
| 생성 패턴 | 추상 팩토리 패턴 | 피자와 음료를 함께 생성 |
| 생성 패턴 | 빌더 패턴 | 양식에 따라 피자 레시피 미리 구성 |
| 생성 패턴 | 프로토타입 패턴 | 기존 피자 레시피를 복제하여 새로운 레시피 생성 |
| 구조 패턴 | 어댑터 패턴 | 피자 주문 시스템과 결제 시스템 연결 |
| 구조 패턴 | 브리지 패턴 | 피자 종류와 크기를 분리하여 독립적으로 확장 |
| 구조 패턴 | 컴포지트 패턴 | 피자 회사 조직도를 트리 구조로 표현 |
| 구조 패턴 | 데코레이터 패턴 | 피자에 추가 재료를 동적으로 추가 |
| 구조 패턴 | 퍼사드 패턴 | 피자 제작이 어려운 고객을 위한 간단한 메뉴판 제공 |
| 구조 패턴 | 플라이웨이트 패턴 | 동일한 피자 레시피를 여러 주문에서 공유 |
| 구조 패턴 | 프록시 패턴 | 피자 배달 서비스에 대한 접근 제어 |
| 행동 패턴 | 책임 연쇄 패턴 | 피자 주문 처리 과정에서 여러 단계를 거침 |
| 행동 패턴 | 커맨드 패턴 | 피자 주문을 객체로 캡슐화하여, 주문 취소나 재주문 가능 |
| 행동 패턴 | 인터프리터 패턴 | 외국인 고객의 주문을 해석하는 패턴 |
| 행동 패턴 | 이터레이터 패턴 | 피자 메뉴를 순차적으로 탐색 |
| 행동 패턴 | 중재자 패턴 | 피자 주문 시스템과 결제 시스템 간의 상호작용 중재 |
| 행동 패턴 | 메멘토 패턴 | 피자 주문 상태를 저장하고, 이전 상태로 되돌리기 |
| 행동 패턴 | 옵저버 패턴 | 피자 배달 상태 변경 시 고객에게 알림 |
| 행동 패턴 | 상태 패턴 | 피자 주문 상태에 따라 행동 변경 (예: 주문 대기, 제작 중, 배달 중) |
| 행동 패턴 | 전략 패턴 | 피자 종류에 따라 다른 피자 제작 전략 선택 |
| 행동 패턴 | 템플릿 메서드 패턴 | 피자 제작 과정의 기본 구조 정의 (예: 재료 준비, 굽기, 포장) |
| 행동 패턴 | 비지터 패턴 | 배달원 지도에서 이미 배달된 피자 확인 |