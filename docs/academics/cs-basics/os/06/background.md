---
layout: default
title: Background
parent: 6. Process Synchronization
grand_parent: Operating Systems
nav_order: 1
---

# 🔄 배경

프로세스는 독립적으로 실행되는 프로그램입니다.
때문에 프로세스는 서로 메모리를 공유하지 않습니다.
하지만 프로세스 간에 통신이 필요할 때가 있습니다.
이때 동기화 문제가 발생할 수 있습니다.

어떤 문제가 발생하는지 살펴보겠습니다.

## 프로세스 간 통신

- 프로세스 간 통신 방법
  - 메시지 전달
  - 공유 메모리 → 충돌(confliction)이 발생할 수 있음!!

메시지 전달 방식은 프로세스 간에 메시지를 주고받는 방식입니다.
하지만 이 방식은 성능이 떨어질 수 있습니다.
왜냐하면 메시지를 주고받는 과정에서 오버헤드가 발생하기 때문입니다.
반면 공유 메모리 방식은 프로세스가 메모리를 공유하여 데이터를 주고받는 방식입니다.
이 방식은 성능이 좋지만, 동기화 문제가 발생할 수 있습니다.

- 생산자-소비자 문제
  - 공유 메모리를 통한 통신의 예시

생산자-소비자 문제는 프로세스 간의 통신을 다루는 고전적인 문제입니다.
생산자는 데이터를 생성하고 소비자는 데이터를 소비합니다.
생산자와 소비자는 서로 다른 프로세스입니다.
생산자는 데이터를 생성하고 소비자는 데이터를 소비합니다.
소비자는 생산자가 생성한 데이터를 소비합니다.
이를 통해 생산자와 소비자는 서로 통신합니다.

```
버퍼 (공유 메모리)
생산자 → 정보 → 소비자
순환 큐로 구현됨
```

---

## 공유 데이터의 동시 접근

생산자와 소비자가 공유 메모리를 통해 통신할 때, 동시 접근 문제가 발생할 수 있습니다.
생산자가 데이터를 생성하는 동안 소비자가 데이터를 소비할 수 있습니다.
또한 소비자가 데이터를 소비하는 동안 생산자가 데이터를 생성할 수 있습니다.
이때 생산자와 소비자가 동시에 공유 메모리에 접근하게 되면, 데이터의 일관성이 깨질 수 있습니다.

**생산자**
```c
while (true) {
  while (counter == BUFFER_SIZE);
  buffer[in] = nextProduced;
  in = (in + 1) % BUFFER_SIZE;
  counter++;
}
```

**`counter++`의 구현**
```
register1 = counter
register1 = register1 + 1
counter = register1
```

**소비자**
```c
while (true) {
  while (counter == 0);
  nextConsumed = buffer[out];
  out = (out + 1) % BUFFER_SIZE;
  counter--;
}
```

**`counter--`의 구현**
```
register2 = counter
register2 = register2 - 1
counter = register2
```

> 수정 작업 중 스위칭이 발생할 수 있음!

---

## 동기화 문제

생산자와 소비자가 동시에 공유 메모리에 접근할 때, 데이터의 일관성이 깨질 수 있습니다.
이때 발생하는 문제를 동기화 문제라고 합니다.
또한 이 문제가 발생한 상황을 경쟁 상태(Race condition)라고 합니다.
경쟁 상태는 두 개 이상의 프로세스가 동시에 공유 자원에 접근할 때 발생하는 문제입니다.

**문제가 되는 상황:**
- `counter`의 초기값 = 5
- 생산자는 증가, 소비자는 감소를 동시에 수행
- 이상적으로: `counter = 5`  
- 실제로는: `counter = 4` 또는 `counter = 6`이 될 수 있음

**동시 실행 예시**
```
생산자:    소비자:
reg1 = 5     reg2 = 5
reg1 = 6     reg2 = 4
counter = 6  counter = 4
```

→ 경쟁 상태(Race condition) 발생 가능
